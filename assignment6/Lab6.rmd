# Lab 6

## Data preparation

```{r}
#library(car)
require(minpack.lm)
library("stats4") # for MLE
library("VGAM") # for the Riemann-zeta function
library("dplyr")
library("latex2exp")
```

# Degree sequence

```{r}
# Auxiliary functions to be used later
get_AIC_degseq <- function(m2logL,K,N) {
  m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
```

```{r}
poisson <- function( k , lambda ){
  lambda**k * exp(-lambda) / factorial(k) / ( 1 - exp(-lambda))
}

geometric <- function( k , q ){
  (1-q)**k*q
}

zeta_3 <- function( k ){
  k**(-3)/zeta(3)
}

zeta_g <- function( k , gamma ){
  k**(-gamma)/zeta(gamma)
}

right_truncated_zeta <- function( k , gamma , km ){
  k**(-gamma)/sum( (1:floor(km)) ** (-gamma) )
}

altmann <- function( k , n , gamma , delta ){
  c = 1 / sum( (1:n) **(-gamma)*exp(-(1:n)*delta ) )
  c*k**(-gamma)*exp(-delta*k)
}
```

```{r}
# Log likelihood functions

get_LL_functions <- function(N, M, M_prime, kmax, C) {
  minus_log_likelihood_poisson <- function(lambda) {
    -M * log(lambda) + N*(lambda+log(1-exp(-lambda))) + C
  }
  
  minus_log_likelihood_geometric <- function(q) {
    ((N-M)*log(1-q))-N*log(q)
  }
  
  minus_log_likelihood_zeta <- function(gamma) {
    N * log(zeta(gamma)) + gamma * M_prime
  }
  
  minus_log_likelihood_zetafixed <- function() {
    N * log((pi^3)/6) + 2*M_prime
  }
  
  minus_log_likelihood_rightzeta <- function(kmax, gamma) {
    N * log(sum(1/(1:kmax)^-gamma)) + gamma * M_prime
  }
  
  minus_log_likelihood_altmann <- function(gamma, delta) {
    d = sum( (1:N) **(-gamma)*exp(-(1:N)*delta ) )
    N*log(d) + gamma*M_prime + delta*M
  }
  
  LL_functions <- c(
    poisson = minus_log_likelihood_poisson,
    geometric = minus_log_likelihood_geometric,
    zeta = minus_log_likelihood_zeta,
    zetafixed = minus_log_likelihood_zetafixed,
    rightzeta = minus_log_likelihood_rightzeta,
    altmann = minus_log_likelihood_altmann
  )
  
  return(LL_functions)
}
```

```{r}
# Meta function that returns the best fit for modeling the degree sequence
# degree_sequence is a numeric vector with the degree of every vertex
fit_degree_sequence <- function(degree_sequence) {

  N <- as.integer(sum(degree_sequence$f))      # Number of nodes
  k_max <- max(degree_sequence$k)  # Maximum degree
  M <- as.integer(sum(degree_sequence$f * degree_sequence$k))            # Total cumulative degree/Sum of nodes
  M_prime = as.integer(sum(degree_sequence$f * log(degree_sequence$k)))  # Logarithmic cumulative degree/Logarithmic sum of nodes
  C <-sum( degree_sequence$f[degree_sequence$k > 1] * sapply(degree_sequence$k[degree_sequence$k > 1], function(ki) sum(log(2:ki)) )) # Parameter C
  
  LL_functions <- get_LL_functions(N, M, M_prime, k_max, C)

  mles <- list()
  AICs <- c()
  
  print('Fitting degree sequence')
  
  # POISSON
  print('Poisson')
  #lambda0 <- M/N
  lambda0 <- 1.000
  mle_fit <- mle(LL_functions[['poisson']], start = list(lambda = lambda0), method = "L-BFGS-B", lower = c(0.000001))
  mles[['poisson']] <- mle_fit
  AICs <- c(AICs, 'poisson' = get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 1, N))
  
  
  # GEOMETRIC
  print('Geometric')
  tryCatch(
    {
      q0 <- as.numeric(N/M)
      mle_fit <- mle(LL_functions[['geometric']], start = list(q = q0), method = "L-BFGS-B", lower = c(0.00001), upper = (0.99999))
      mles[['geometric']] <- mle_fit
      AICs['geometric'] <- get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 1, N)
    }, error = function(e) {
      print(paste("Failed to fit model 3:", e$message))
      mles[['geometric']] <- NA
      AICs['geometric'] <- Inf
    }
  )
  
  # ZETA WITH GAMMA=3
  print('Zetafixed')
  AICs['zetafixed'] <- get_AIC_degseq(2*LL_functions[['zetafixed']](), 0, N)
  
  # ZETA
  print('Zeta')
  gamma0 <- 3 #maybe a better initial value can be inferred from the slope of a linear regression in a log_log scale
  mle_fit <- mle(LL_functions[['zeta']], start = list(gamma= gamma0), method = "L-BFGS-B", lower = c(1.0000001))
  mles[['zeta']] <- mle_fit
  AICs['zeta'] <- get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 1, N)
  
  # RIGHT-TRUNCATED ZETA
  print('Rightzeta')
  #kmax0 <- N
  #mle_fit <- mle(LL_functions[['rightzeta']], start = list(kmax=kmax0, gamma= gamma0), method = "L-BFGS-B", lower = c(kmax0,0.00001), upper = c(Inf, Inf))
  #mles[['rightzeta']] <- mle_fit
  #AICs['rightzeta'] <- get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 2, N)
  
  m2logL_prev <-  1e10
  m2logL <-  1e10-1
  km  <- k_max
  while(abs(m2logL-m2logL_prev)>1e-6 && m2logL < m2logL_prev){
    likelihood <- function(gamma) {
      LL_functions[['rightzeta']](km, gamma)
    }
    mle_fit_prev <- mle_fit
    mle_fit <- mle( likelihood ,
                    start = list( gamma = 2 ) , method = "L-BFGS-B" , 
                    lower = c( 0.00000001 ) , upper = c( 100 ) )
  
    m2logL_prev <- m2logL
    m2logL <- attributes(summary(mle_fit))$m2logL
    km <- km+round(0.05*k_max)
  }
  #attributes(summary(mle_fit_prev))$coef[2] <- km-round(0.05*k_max)
  mles[['rightzeta']] <- mle_fit_prev
  AICs['rightzeta'] <- get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 2, N)
  
  
  # ALTMANN
  print('Altmann')
  delta0=2
  mle_fit <- mle(LL_functions[['altmann']], start = list(gamma=gamma0, delta= delta0), method = "L-BFGS-B", lower = c(0.00001, 0.00001), upper=c(100,100))
  mles[['altmann']] <- mle_fit
  AICs['altmann'] <- get_AIC_degseq(attributes(summary(mle_fit))$m2logL, 2, N)
  
  return(list(mles=mles, AICs=AICs))
}
```


```{r}
get_best_function <- function(name, model) {
  best_func <- switch(
    best_name,
    "poisson" = function(k) coef(best_model)[1]**k * exp(-coef(best_model)[1]) / factorial(k) / ( 1 - exp(-coef(best_model)[1])),
    "geometric" = function(k) (1-coef(best_model)[1])**k*coef(best_model)[1],
    "zetafixed" = function(k) k**(-3)/zeta(3),
    "zeta" = function(k) k**(-coef(best_model)[1])/zeta(coef(best_model)[1]),
    "rightzeta" = function(k) k**(-coef(best_model)[1])/ sum( (1:km)^(-coef(best_model)[1])),
    "altmann" = function(k) k**(-coef(best_model)[1])*exp(-coef(best_model)[2]*k) / sum( (1:sum(ds$f)) **(-coef(best_model)[1])*exp(-(1:sum(ds$f))*coef(best_model)[2] ) ),
  )
  return(best_func)
}
```


# Scaling of vertex degree over time

```{r}
# Generic function to compute the AIC
# RSS -> residual sum of squares
# n -> number of points in the data
# p -> number of parameters in the model
get_AIC_scaling <- function(RSS, n, p) {
  return(n*log(2*pi) + n*log(RSS/n) + n + 2*(p + 1))
}
```

```{r}
# Define the formulas for all the models
# Note that the one for model 0 is not used
# For the additive models, the fourth parameter (d) is represented by the
#  variable p (for 'plus') to avoid confusion with d representing the degree
get_NLR_functions <- function() {
  ft_0  <- d ~ a * t
  ft_1  <- d ~ a * t^(1/2)
  ft_2  <- d ~ a * t^b
  ft_3  <- d ~ a * exp(c*t)
  ft_4  <- d ~ a * log(t + p1)
  ft_0p <- d ~ a * t + p
  ft_1p <- d ~ a * t^(1/2) + p
  ft_2p <- d ~ a * t^b + p
  ft_3p <- d ~ a * exp(c*t) + p
  ft_4p <- d ~ a * log(t + p1) + p2
  
  NLR_functions <- c(
    ft_0 = ft_0,
    ft_1 = ft_1,
    ft_2 = ft_2,
    ft_3 = ft_3,
    ft_4 = ft_4,
    ft_0p = ft_0p,
    ft_1p = ft_1p,
    ft_2p = ft_2p,
    ft_3p = ft_3p,
    ft_4p = ft_4p
  )
  
  return(NLR_functions)
}

```

```{r}
# Meta function that returns the best fit for modeling the evolution of the vertex degree over time
# dat is a data frame with columns t (time step) and d (degree)
fit_degree_evolution <- function(dat, trace_ON=FALSE) {
  
  nlms <- list()
  AICs <- c()
  
  NLR_functions <- get_NLR_functions()
  
  if (trace_ON) print(0)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_0']], data=dat, start=list(a=1), trace=trace_ON)
      nlms[['ft_0']] <- nlmod
      AICs <- c(AICs, 'ft_0' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 1))
    }, error = function(e) {
      print(paste("Failed to fit model 0:", e$message))
    }
  )
  
  
  if (trace_ON) print(1)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_1']], data=dat, start=list(a=1), trace=trace_ON)
      nlms[['ft_1']] <- nlmod
      AICs <- c(AICs, 'ft_1' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 1))
    }, error = function(e) {
      print(paste("Failed to fit model 1:", e$message))
    }
  )
  
  if (trace_ON) print(2)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_2']], data=dat, start=list(a=1, b=1), trace=trace_ON)
      nlms[['ft_2']] <- nlmod
      AICs <- c(AICs, 'ft_2' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 2))
    }, error = function(e) {
      print(paste("Failed to fit model 2:", e$message))
    }
  )
  
  if (trace_ON) print(3)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_3']], data=dat, start=list(a=1, c=0.0000001), trace=trace_ON)
      nlms[['ft_3']] <- nlmod
      AICs <- c(AICs, 'ft_3' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 2))
    }, error = function(e) {
      print(paste("Failed to fit model 3:", e$message))
    }
  )
  
  if (trace_ON) print(4)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_4']], data=dat, start=list(a=1, p1=5), algorithm="port", trace=trace_ON)
      #nlmod <- nls(NLR_functions[['ft_4']], data=dat, start=list(a=1, p1=5), lower=list(p1=0.0001), algorithm="port", trace=trace_ON)
      nlms[['ft_4']] <- nlmod
      AICs <- c(AICs, 'ft_4' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 2))
    }, error = function(e) {
      print(paste("Failed to fit model 4:", e$message))
    }
  )
  
  if (trace_ON) print(0)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_0p']], data=dat, start=list(a=1, p=0), trace=trace_ON)
      nlms[['ft_0p']] <- nlmod
      AICs <- c(AICs, 'ft_0p' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 2))
    }, error = function(e) {
      print(paste("Failed to fit model 0+:", e$message))
    }
  )
  
  if (trace_ON) print(1)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_1p']], data=dat, start=list(a=1, p=0), trace=trace_ON)
      nlms[['ft_1p']] <- nlmod
      AICs <- c(AICs, 'ft_1p' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 2))
    }, error = function(e) {
      print(paste("Failed to fit model 1+:", e$message))
    }
  )
  
  if (trace_ON) print(2)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_2p']], data=dat, start=list(a=1, b=1, p=0), trace=trace_ON, control=nls.control(maxiter = 1000))
      nlms[['ft_2p']] <- nlmod
      AICs <- c(AICs, 'ft_2p' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 3))
    }, error = function(e) {
      print(paste("Failed to fit model 2+:", e$message))
    }
  )
  
  if (trace_ON) print(3)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_3p']], data=dat, start=list(a=1, c=0.0000001, p=0), trace=trace_ON, control=nls.control(maxiter = 1000))
      nlms[['ft_3p']] <- nlmod
      AICs <- c(AICs, 'ft_3p' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 3))
    }, error = function(e) {
      print(paste("Failed to fit model 3+:", e$message))
    }
  )
  
  if (trace_ON) print(4)
  tryCatch(
    {
      nlmod <- nlsLM(NLR_functions[['ft_4p']], data=dat, start=list(a=1, p1=5, p2=0), trace=trace_ON)
      nlms[['ft_4p']] <- nlmod
      AICs <- c(AICs, 'ft_4p' = get_AIC_scaling(sum(resid(nlmod)^2), nrow(dat), 3))
    }, error = function(e) {
      print(paste("Failed to fit model 4+:", e$message))
    }
  )
  
  return(list(nlms=nlms, AICs=AICs))
}
```



# Exercises

## 2.2 BA Scaling

```{r}
vtx_ids <- c('1','10','100','1000','10000','100000')

scalings <- list()

for (i in vtx_ids) {
  # Read data
  filename <- paste('data/full_ba_evolution_', i, '.csv', sep='')
  #idxname <- as.character(format(i, scientific = FALSE))
  
  scalings[[i]] <- read.csv(filename, header=FALSE)
  
  # Rename columns
  colnames(scalings[[i]])[colnames(scalings[[i]]) == "V1"] <- "d"
  
  # Add the time column
  scalings[[i]]$t <- seq(1, length.out = nrow(scalings[[i]]))
  
  # Remove rows before t_i (ie when d is 0)
  scalings[[i]] <- scalings[[i]][scalings[[i]]$d!=0,]
}
```

Check visually if ki 0 (t) is about the same for every vertex chosen for the ranges of time the vertices coexist (make a plot).

```{r}
for (i in vtx_ids) {
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab="time", ylab="vertex degree")
}
```

```{r}
# Assuming vtx_ids is a vector of indices
plot(scalings[[vtx_ids[1]]]$t, scalings[[vtx_ids[1]]]$d, type='l', xlab="time", ylab="vertex degree", col=1)

# Loop through the remaining indices and add them to the plot
for (i in vtx_ids[-1]) {
  #par(new=TRUE)
  #lines(scalings[[i]]$t, scalings[[i]]$d, col=i, xlab="", ylab="")
  #plot(scalings[[vtx_ids[i]]]$t, scalings[[vtx_ids[i]]]$d, type='l', axes=FALSE, xlab="time", ylab="vertex degree", col=1)
  #axis(side=4, at=pretty(range(scalings[[vtx_ids[6]]]$d)))
}

# Optionally, add a legend if needed
legend("topright", legend=vtx_ids, col=1:length(vtx_ids), lty=1, cex=0.8)


```


Check if the power-law dependency with 1/2 exponent gives the best fit to all the time series. Use model selection by (1) using non-linear regression to estimate best parameters for each of the functions listed in Section 1.2, and (2) using AIC as indicated in Section 1.2 to select the best model. Add the theoretical power-law defined by Eq. 2 to the plot.

```{r}
for (i in vtx_ids) {
  ev_results <- fit_degree_evolution(scalings[[i]], FALSE)
  (best_name <- names(which.min(ev_results$AICs)))
  best_model <- ev_results$nlms[[best_name]]
  
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab = "time", ylab = "degree", main=best_name)
  lines(scalings[[i]]$t, fitted(best_model), col = "green")
}
```


## 2.3 BA Degree distribution

Check if the distribution giving the best fit is a power-law with a -3 exponent (modelled as a zeta distribution or a right-truncated zeta distribution, both with a -3 exponent). Use model selection (lab session 2).

```{r}
ds <- read.csv('data/full_ba_deg_seq.txt.mean', sep=" ", header=FALSE)
colnames(ds) = c("k","f")
for( j in 1:length(ds) ){
  #Yes, this is weird, but how R manages factors is weirder
  ds$k[j] = as.numeric(as.character(ds$k[j])) 
}
ds$p = ds$f/sum(ds$f)

#ds$f <- 0.05*ds$f
#ds$p <- 0.05*ds$p

ds <- ds[-1,]
```

```{r}
ds_results <- fit_degree_sequence(ds)
```

```{r}
(best_name <- names(which.min(ds_results$AICs)))
best_model <- ds_results$mles[[best_name]]
best_func <- get_best_function(best_name, best_model)
```

```{r}
matplot(ds$k,ds$p, main = "All models with Barabási-Albert",
        xlab = "number of vertices", ylab = "degree (probability)" , log = "xy" , pch = 19)
#matplot(deg_spec$k,deg_spec$p, main = "All models with Barabási-Albert",
#        xlab = "degree", ylab = "number of vertices" , log = "xy" , pch = 19 , cex.lab=1.6,  cex.main=1.8, cex.names=1.4 )

lines(ds$k, poisson(ds$k, coef(ds_results$mles[["poisson"]])[1]), col = 2)
lines(ds$k, geometric(ds$k, coef(ds_results$mles[["geometric"]])[1]), col = 3)
lines(ds$k, zeta_3(ds$k), col = 4 )
lines(ds$k, zeta_g(ds$k, coef(ds_results$mles[["zeta"]])[1]), col = 5)
lines(ds$k, right_truncated_zeta(ds$k, coef(ds_results$mles[["rightzeta"]])[1], max(ds$k)), col = 6)
lines(ds$k, altmann(ds$k, sum(ds$f), coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]), col = 7)

legend(10**(0.60*(log10(max(ds$k))+log10(min(ds$k)))) , max(ds$p) , 
      legend = c(TeX(sprintf(r'(D. Poisson($\lambda = %0.3f$))', coef(ds_results$mles[["poisson"]])[1])),
                 TeX(sprintf(r'(D. Geom($\q = %0.3f$))', coef(ds_results$mles[["geometric"]])[1])),
                   "Zeta(3)",
                 TeX(sprintf(r'(Zeta($\gamma = %0.3f$))', coef(ds_results$mles[["zeta"]])[1])),
                 TeX(sprintf(r'(Trunc Zeta($\gamma = %0.3f, k_{max} = %f$))', coef(ds_results$mles[["rightzeta"]])[1], max(ds$k))),
                 TeX(sprintf(r'(Altmann($\gamma = %0.3f, \delta = %0.3f$))', coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]))
        ), 
        col =2:7 , cex = 0.8 , lty = rep(1,4) 
      )  
```



## 3.1 Random Attachment Scaling


```{r}
vtx_ids <- c('1','10','100','1000','10000','100000')

scalings <- list()

for (i in vtx_ids) {
  # Read data
  filename <- paste('data/random_attach_evolution_', i, '.csv', sep='')
  #idxname <- as.character(format(i, scientific = FALSE))
  
  scalings[[i]] <- read.csv(filename, header=FALSE)
  
  # Rename columns
  colnames(scalings[[i]])[colnames(scalings[[i]]) == "V1"] <- "d"
  
  # Add the time column
  scalings[[i]]$t <- seq(1, length.out = nrow(scalings[[i]]))
  
  # Remove rows before t_i (ie when d is 0)
  scalings[[i]] <- scalings[[i]][scalings[[i]]$d!=0,]
}
```

Check visually if ki 00 (t) is about the same for every vertex chosen for the ranges of time the vertices coexist (make a plot).

```{r}
for (i in vtx_ids) {
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab="time", ylab="vertex degree")
}
```
Check if Eq. 5 holds through the logarithmic function of model 4 (or 4+). Check if that model gives the best fit to all the time series (use model selection). If that is the case check that a ≈ m0 and d1 ≈ m0 − 1.

```{r}
for (i in vtx_ids) {
  ev_results <- fit_degree_evolution(scalings[[i]], FALSE)
  (best_name <- names(which.min(ev_results$AICs)))
  best_model <- ev_results$nlms[[best_name]]
  
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab = "time", ylab = "degree", main=best_name)
  lines(scalings[[i]]$t, fitted(best_model), col = "green")
}
```



## 3.2 Random Attachment Degree distribution

Check if the distribution giving the best fit is a power-law with a -3 exponent (modelled as a zeta distribution or a right-truncated zeta distribution, both with a -3 exponent). Use model selection (lab session 2).

```{r}
ds <- read.csv('data/random_attach_deg_seq.txt.mean', sep=" ", header=FALSE)
colnames(ds) = c("k","f")
for( j in 1:length(ds) ){
  #Yes, this is weird, but how R manages factors is weirder
  ds$k[j] = as.numeric(as.character(ds$k[j])) 
}
ds$p = ds$f/sum(ds$f)

ds <- ds[-1,]
```

```{r}
ds_results <- fit_degree_sequence(ds)
```

```{r}
(best_name <- names(which.min(ds_results$AICs)))
best_model <- ds_results$mles[[best_name]]
best_func <- get_best_function(best_name, best_model)
```

```{r}
matplot(ds$k,ds$p, main = "All models with Growth + Random Attachment",
        xlab = "number of vertices", ylab = "degree (probability)" , log = "xy" , pch = 19)
#matplot(deg_spec$k,deg_spec$p, main = "All models with Barabási-Albert",
#        xlab = "degree", ylab = "number of vertices" , log = "xy" , pch = 19 , cex.lab=1.6,  cex.main=1.8, cex.names=1.4 )

lines(ds$k, poisson(ds$k, coef(ds_results$mles[["poisson"]])[1]), col = 2)
lines(ds$k, geometric(ds$k, coef(ds_results$mles[["geometric"]])[1]), col = 3)
lines(ds$k, zeta_3(ds$k), col = 4 )
lines(ds$k, zeta_g(ds$k, coef(ds_results$mles[["zeta"]])[1]), col = 5)
lines(ds$k, right_truncated_zeta(ds$k, coef(ds_results$mles[["rightzeta"]])[1], max(ds$k)), col = 6)
lines(ds$k, altmann(ds$k, sum(ds$f), coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]), col = 7)

legend(4 , 0.0001 , 
      legend = c(TeX(sprintf(r'(D. Poisson($\lambda = %0.3f$))', coef(ds_results$mles[["poisson"]])[1])), 
                 TeX(sprintf(r'(D. Geom($\q = %0.3f$))', coef(ds_results$mles[["geometric"]])[1])), 
                   "Zeta(3)", 
                 TeX(sprintf(r'(Zeta($\gamma = %0.3f$))', coef(ds_results$mles[["zeta"]])[1])),
                 TeX(sprintf(r'(Trunc Zeta($\gamma = %0.3f, k_{max} = %f$))', coef(ds_results$mles[["rightzeta"]])[1], max(ds$k))),
                 TeX(sprintf(r'(Altmann($\gamma = %0.3f, \delta = %0.3f$))', coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]))
        ), 
        col =2:7 , cex = 0.8 , title = "Fit lines" , lty = rep(1,4) 
      )  
```


## 3.1 No growth Scaling


```{r}
vtx_ids <- c('1','10','100')

scalings <- list()

for (i in vtx_ids) {
  # Read data
  filename <- paste('data/no_growth_evolution_', i, '.csv', sep='')
  #idxname <- as.character(format(i, scientific = FALSE))
  
  scalings[[i]] <- read.csv(filename, header=FALSE)
  
  # Rename columns
  colnames(scalings[[i]])[colnames(scalings[[i]]) == "V1"] <- "d"
  
  # Add the time column
  scalings[[i]]$t <- seq(1, length.out = nrow(scalings[[i]]))
  
  # Remove rows before t_i (ie when d is 0)
  scalings[[i]] <- scalings[[i]][scalings[[i]]$d!=0,]
}
```

Check visually if ki 00 (t) is about the same for every vertex chosen for the ranges of time the vertices coexist (make a plot).

```{r}
for (i in vtx_ids) {
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab="time", ylab="vertex degree")
}
```
Check if Eq. 5 holds through the logarithmic function of model 4 (or 4+). Check if that model gives the best fit to all the time series (use model selection). If that is the case check that a ≈ m0 and d1 ≈ m0 − 1.

```{r}
for (i in vtx_ids) {
  ev_results <- fit_degree_evolution(scalings[[i]], FALSE)
  (best_name <- names(which.min(ev_results$AICs)))
  best_model <- ev_results$nlms[[best_name]]
  
  plot(scalings[[i]]$t, scalings[[i]]$d, type='l', xlab = "time", ylab = "degree", main=best_name)
  lines(scalings[[i]]$t, fitted(best_model), col = "green")
}
```



## 3.2 No growth Degree distribution

Check if the distribution giving the best fit is a power-law with a -3 exponent (modelled as a zeta distribution or a right-truncated zeta distribution, both with a -3 exponent). Use model selection (lab session 2).

```{r}
ds <- read.csv('data/no_growth_deg_seq.txt.mean', sep=" ", header=FALSE)
colnames(ds) = c("k","f")
for( j in 1:length(ds) ){
  #Yes, this is weird, but how R manages factors is weirder
  ds$k[j] = as.numeric(as.character(ds$k[j])) 
}
ds$p = ds$f/sum(ds$f)

ds <- ds[-1,]
```

```{r}
ds_results <- fit_degree_sequence(ds)
```

```{r}
(best_name <- names(which.min(ds_results$AICs)))
best_model <- ds_results$mles[[best_name]]
best_func <- get_best_function(best_name, best_model)
```

```{r}
matplot(ds$k,ds$p, main = "All models with No Growth + Preferential Attachment",
        xlab = "number of vertices", ylab = "degree (probability)" , log = "xy" , pch = 19)
#matplot(deg_spec$k,deg_spec$p, main = "All models with Barabási-Albert",
#        xlab = "degree", ylab = "number of vertices" , log = "xy" , pch = 19 , cex.lab=1.6,  cex.main=1.8, cex.names=1.4 )

lines(ds$k, poisson(ds$k, coef(ds_results$mles[["poisson"]])[1]), col = 2)
#lines(ds$k, geometric(ds$k, coef(ds_results$mles[["geometric"]])[1]), col = 3)
lines(ds$k, zeta_3(ds$k), col = 4 )
lines(ds$k, zeta_g(ds$k, coef(ds_results$mles[["zeta"]])[1]), col = 5)
lines(ds$k, right_truncated_zeta(ds$k, coef(ds_results$mles[["rightzeta"]])[1], max(ds$k)), col = 6)
lines(ds$k, altmann(ds$k, sum(ds$f), coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]), col = 7)

legend(5450, 5e-05, 
      legend = c(TeX(sprintf(r'(D. Poisson($\lambda = %0.3f$))', coef(ds_results$mles[["poisson"]])[1])), 
                 #TeX(sprintf(r'(D. Geom($\q = %0.3f$))', coef(ds_results$mles[["geometric"]])[1])), 
                   "Zeta(3)", 
                 TeX(sprintf(r'(Zeta($\gamma = %0.3f$))', coef(ds_results$mles[["zeta"]])[1])),
                 TeX(sprintf(r'(Trunc Zeta($\gamma = %0.3f, k_{max} = %f$))', coef(ds_results$mles[["rightzeta"]])[1], max(ds$k))),
                 TeX(sprintf(r'(Altmann($\gamma = %0.3f, \delta = %0.3f$))', coef(ds_results$mles[["altmann"]])[1], coef(ds_results$mles[["altmann"]])[2]))
        ), 
        col =2:7 , cex = 0.8 , title = "Fit lines" , lty = rep(1,4) 
      )  
```